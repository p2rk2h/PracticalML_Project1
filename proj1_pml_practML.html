<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Executive Summary</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><br> </br></p>

<h2>Executive Summary</h2>

<p>Three machine-learning classification algorithms and their predictions are examined and compared on a training and test dataset from the Weight Lifting Exercise Dataset.  All the 3 algorithms of <em>K-Nearest Neighbot</em>, <em>SVM Radial</em>, and <em>Random Forest</em> predicted well on the 20 testing cases, all giving identical prediction on identifying from among the 5 activitiesi being monitored.  The training accuracies after a 3-fold cross validation are respectively 91%, 93%, and 99%, indicating that <em>Random Forest</em> classification is preferred for this dataset.  Resulting 20 prediction activity results are written in separate individual text files.
<br> </br></p>

<h2>Overview</h2>

<p>This course project for Practical Machine Learning by Johns Hopkins University Coursera is to analyze the data from acceleromter activities of Weight Lifting Excercise Dataset (see the URL link below) using machine learning modeling to predict 20 different test cases.</p>

<h3>Assignment Context</h3>

<p>Using devices such as Jawbone Up, Nike FuelBand, and Fitbit, it is now possible to collect a large amount of data about personal activity relatively inexpensively.  These type of devices are part of the quantified self movement –- a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks.  One thing that people regularly do is quantify how much of a particular activity they do, but they rarely quantify how well they do it.  In this project, the goal will be to use data from accelerometers on the belt, forearm, arm, and dumbell of 6 participants.  They were asked to perform barbell lifts correctly and incorrectly in 5 different ways.  More information is available from the website here: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a> (see the section on the Weight Lifting Exercise Dataset)</p>

<p>The training and testing data for this project are available from: </p>

<p><a href="https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv">https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv</a>
<a href="https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv">https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv</a></p>

<p>The data come from this source: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a></p>

<h3>Assignment Question</h3>

<p>The goal of the project is to predict the manner in which they did the exercise.  This is the &ldquo;classe&rdquo; variable in the training set.  You may use any of the other variables to predict with.  You should create a report describing how you built your model, how you used cross validation, what you think the expected out of sample error is, and why you made the choices you did.  You will also use your prediction model to predict 20 different test cases. </p>

<ol>
<li>Your submission should consist of a link to a Github repo with your R markdown and compiled HTML file describing your analysis. Please constrain the text of the writeup to &lt; 2000 words and the number of figures to be less than 5. It will make it easier for the graders if you submit a repo with a gh-pages branch so the HTML page can be viewed online (and you always want to make it easy on graders :-).</li>
<li>You should also apply your machine learning algorithm to the 20 test cases available in the test data above. Please submit your predictions in appropriate format to the programming assignment for automated grading. See the programming assignment for additional details. 
<br> </br></li>
</ol>

<h2>Summary of Data Preparation and Analysis</h2>

<p>Detailed preliminary analyses (not shown for brevity) indicate the use of known data columns for outcome and non-predictor variables.  Though tree classification was also examined and resulted in the same prediction, it&#39;s omitted here for brevity.  The analyses below start with the following data initialization and reduction:</p>

<pre><code class="r"># initialize
library( caret )
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code class="r">dwldUrl &lt;- &#39;https://d396qusza40orc.cloudfront.net/predmachlearn&#39;
subDir &lt;- &#39;.&#39;   # default current working directory
trainFl &lt;- &#39;pml-training.csv&#39;
testFl &lt;- &#39;pml-testing.csv&#39;
</code></pre>

<p><br> </br></p>

<pre><code class="r"># load training and testing data
source( &#39;ldPmlPrjDat.R&#39; )   # a utility function
trainPml &lt;- ldPmlPrjDat( trainFl , subDir , paste( dwldUrl , trainFl , sep = &#39;/&#39; ) )
testPml &lt;- ldPmlPrjDat( testFl , subDir , paste( dwldUrl , testFl , sep = &#39;/&#39; ) )
dim( trainPml ) ; dim( testPml )    # initial number of rows and columns
</code></pre>

<pre><code>## [1] 19622   160
</code></pre>

<pre><code>## [1]  20 160
</code></pre>

<p><br> </br></p>

<h2>Data Filtering:</h2>

<pre><code class="r"># data filtering to remove any NA or empty strings so no imputing is required
trainPmlF &lt;- trainPml[ , ! sapply( trainPml , function( x ) { any( is.na( x ) || x == &#39;&#39; ) } ) ]
testPmlF &lt;- testPml[ , ! sapply( testPml , function( x ) { any( is.na( x ) || x == &#39;&#39; ) } ) ]
dim( trainPmlF ) ; dim( testPmlF )  # updated number of rows and columns
</code></pre>

<pre><code>## [1] 19622    60
</code></pre>

<pre><code>## [1] 20 60
</code></pre>

<p><br> </br></p>

<h2>Data Cleaning:</h2>

<pre><code class="r"># remove columns which are known to be non-predictor variables
noPrdctrVar &lt;- c( &#39;X&#39; , &#39;user_name&#39; , &#39;raw_timestamp_part_1&#39; , &#39;raw_timestamp_part_2&#39; , &#39;cvtd_timestamp&#39; , &#39;new_window&#39; , &#39;num_window&#39; )
trainPmlF &lt;- trainPmlF[ , - which( colnames( trainPmlF ) %in% noPrdctrVar ) ]
testPmlF &lt;- testPmlF[ , - which( colnames( testPmlF ) %in% noPrdctrVar ) ]
dim( trainPmlF ) ; dim( testPmlF )  # updated number of rows and columns
</code></pre>

<pre><code>## [1] 19622    53
</code></pre>

<pre><code>## [1] 20 53
</code></pre>

<p><br> </br></p>

<h2>Exploraroty Data Preparation:</h2>

<pre><code class="r"># check for training and testing dataset for differing column names
nmNotSame &lt;- ( colnames( trainPmlF ) != colnames( testPmlF ) )
which( nmNotSame == TRUE )  # column indices, if any, where names differ
</code></pre>

<pre><code>## [1] 53
</code></pre>

<pre><code class="r"># name of outcome variable for training dataset
colnames( trainPmlF )[ nmNotSame ]
</code></pre>

<pre><code>## [1] &quot;classe&quot;
</code></pre>

<pre><code class="r"># name of outcome variable for testing dataset
colnames( testPmlF )[ nmNotSame ]
</code></pre>

<pre><code>## [1] &quot;problem_id&quot;
</code></pre>

<pre><code class="r"># ensure training data&#39;s outcome classe is a factor
trainPmlF$classe &lt;- as.factor( trainPmlF$classe ) 
str( trainPmlF$classe )
</code></pre>

<pre><code>##  Factor w/ 5 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
</code></pre>

<p><br> </br></p>

<h2>Cross-Validation Models on Training Dataset:</h2>

<pre><code class="r"># use 3-fold cross validation with trainControl on 3 classifier algorithms, K-Nearest Neighbors, SVM Radial, and Random Forest
cvTrnCtl3 &lt;- trainControl( method = &#39;cv&#39; , number = 3 , verboseIter = TRUE )
</code></pre>

<p><br> </br></p>

<h3>Algorithm 1: <em>KNN</em> on training dataset</h3>

<pre><code class="r">mdlKnn &lt;- train( classe ~ . , data = trainPmlF , method = &#39;knn&#39; , trControl = cvTrnCtl3 )
</code></pre>

<pre><code>## + Fold1: k=5 
## - Fold1: k=5 
## + Fold1: k=7 
## - Fold1: k=7 
## + Fold1: k=9 
## - Fold1: k=9 
## + Fold2: k=5 
## - Fold2: k=5 
## + Fold2: k=7 
## - Fold2: k=7 
## + Fold2: k=9 
## - Fold2: k=9 
## + Fold3: k=5 
## - Fold3: k=5 
## + Fold3: k=7 
## - Fold3: k=7 
## + Fold3: k=9 
## - Fold3: k=9 
## Aggregating results
## Selecting tuning parameters
## Fitting k = 5 on full training set
</code></pre>

<pre><code class="r">str( mdlKnn$results )
</code></pre>

<pre><code>## &#39;data.frame&#39;:    3 obs. of  5 variables:
##  $ k         : int  5 7 9
##  $ Accuracy  : num  0.906 0.883 0.864
##  $ Kappa     : num  0.88 0.852 0.828
##  $ AccuracySD: num  0.00258 0.00267 0.0031
##  $ KappaSD   : num  0.00329 0.00344 0.00401
</code></pre>

<p><br> </br></p>

<h3>Algorithm 2: <em>SVM Radial</em> on training dataset</h3>

<pre><code class="r">mdlSvm &lt;- train( classe ~ . , data = trainPmlF , method = &#39;svmRadial&#39; , trControl = cvTrnCtl3 )
</code></pre>

<pre><code>## Loading required package: kernlab
</code></pre>

<pre><code>## + Fold1: sigma=0.0139, C=0.25 
## - Fold1: sigma=0.0139, C=0.25 
## + Fold1: sigma=0.0139, C=0.50 
## - Fold1: sigma=0.0139, C=0.50 
## + Fold1: sigma=0.0139, C=1.00 
## - Fold1: sigma=0.0139, C=1.00 
## + Fold2: sigma=0.0139, C=0.25 
## - Fold2: sigma=0.0139, C=0.25 
## + Fold2: sigma=0.0139, C=0.50 
## - Fold2: sigma=0.0139, C=0.50 
## + Fold2: sigma=0.0139, C=1.00 
## - Fold2: sigma=0.0139, C=1.00 
## + Fold3: sigma=0.0139, C=0.25 
## - Fold3: sigma=0.0139, C=0.25 
## + Fold3: sigma=0.0139, C=0.50 
## - Fold3: sigma=0.0139, C=0.50 
## + Fold3: sigma=0.0139, C=1.00 
## - Fold3: sigma=0.0139, C=1.00 
## Aggregating results
## Selecting tuning parameters
## Fitting sigma = 0.0139, C = 1 on full training set
</code></pre>

<pre><code class="r">str( mdlSvm$results )
</code></pre>

<pre><code>## &#39;data.frame&#39;:    3 obs. of  6 variables:
##  $ sigma     : num  0.0139 0.0139 0.0139
##  $ C         : num  0.25 0.5 1
##  $ Accuracy  : num  0.868 0.898 0.927
##  $ Kappa     : num  0.833 0.87 0.907
##  $ AccuracySD: num  0.01541 0.01065 0.00766
##  $ KappaSD   : num  0.01956 0.01351 0.00972
</code></pre>

<p><br> </br></p>

<h3>Algorithm 3: <em>Random Forest</em> on training dataset</h3>

<pre><code class="r">mdlRf &lt;- train( classe ~ . , data = trainPmlF , method = &#39;rf&#39; , trControl = cvTrnCtl3 )
</code></pre>

<pre><code>## Loading required package: randomForest
## randomForest 4.6-10
## Type rfNews() to see new features/changes/bug fixes.
</code></pre>

<pre><code>## + Fold1: mtry= 2 
## - Fold1: mtry= 2 
## + Fold1: mtry=27 
## - Fold1: mtry=27 
## + Fold1: mtry=52 
## - Fold1: mtry=52 
## + Fold2: mtry= 2 
## - Fold2: mtry= 2 
## + Fold2: mtry=27 
## - Fold2: mtry=27 
## + Fold2: mtry=52 
## - Fold2: mtry=52 
## + Fold3: mtry= 2 
## - Fold3: mtry= 2 
## + Fold3: mtry=27 
## - Fold3: mtry=27 
## + Fold3: mtry=52 
## - Fold3: mtry=52 
## Aggregating results
## Selecting tuning parameters
## Fitting mtry = 2 on full training set
</code></pre>

<pre><code class="r">str( mdlRf$results )
</code></pre>

<pre><code>## &#39;data.frame&#39;:    3 obs. of  5 variables:
##  $ mtry      : num  2 27 52
##  $ Accuracy  : num  0.993 0.993 0.987
##  $ Kappa     : num  0.991 0.991 0.983
##  $ AccuracySD: num  0.00115 0.00111 0.00295
##  $ KappaSD   : num  0.00145 0.0014 0.00374
</code></pre>

<p><br> </br></p>

<h3>tabulate and compare accuracy</h3>

<pre><code class="r">data.frame( Model = c( &#39;KNN&#39; , &#39;SVM Radial&#39; , &#39;Random Forest&#39; ) , Accuracy = c( round( max( head( mdlKnn$results )$Accuracy ) , 3 ) , round( max( head( mdlSvm$results )$Accuracy ) , 3 ) , round( max( head( mdlRf$results )$Accuracy ) , 3 ) ) )
</code></pre>

<pre><code>##           Model Accuracy
## 1           KNN    0.906
## 2    SVM Radial    0.927
## 3 Random Forest    0.993
</code></pre>

<p><br> </br></p>

<h2>Predictions on Testing Dataset:</h2>

<p>Each of the 3 models are applied on the test dataset to predict among the 5 acitivities:</p>

<pre><code class="r"># run predictions with the 3 models on the 20-case test dataset
prdTstKnn &lt;- predict( mdlKnn , testPmlF )
prdTstSvm &lt;- predict( mdlSvm , testPmlF )
prdTstRf &lt;- predict( mdlRf , testPmlF )

# print the resulting predictions
prdTstKnn ; prdTstSvm ; prdTstRf
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<p><br> </br></p>

<h3>Check for Overall Agreement among the 3 Predictions</h3>

<pre><code class="r"># tabulate and check for consistency in predictions by the 3 models
prdTstPml3 &lt;- data.frame( knn = prdTstKnn , svm = prdTstSvm , rf = prdTstRf )
dim( prdTstPml3 )
</code></pre>

<pre><code>## [1] 20  3
</code></pre>

<pre><code class="r"># recheck row by row for agreement into a new column
prdTstPml3$agree &lt;- ( ( ( prdTstPml3[ , &#39;knn&#39; ] == prdTstPml3[ , &#39;svm&#39; ] ) + ( prdTstPml3[ , &#39;svm&#39; ] == prdTstPml3[ , &#39;rf&#39; ] ) ) == 2 )
prdTstPml3  # table with last column showing each row&#39;s agreement
</code></pre>

<pre><code>##    knn svm rf agree
## 1    B   B  B  TRUE
## 2    A   A  A  TRUE
## 3    B   B  B  TRUE
## 4    A   A  A  TRUE
## 5    A   A  A  TRUE
## 6    E   E  E  TRUE
## 7    D   D  D  TRUE
## 8    B   B  B  TRUE
## 9    A   A  A  TRUE
## 10   A   A  A  TRUE
## 11   B   B  B  TRUE
## 12   C   C  C  TRUE
## 13   B   B  B  TRUE
## 14   A   A  A  TRUE
## 15   E   E  E  TRUE
## 16   E   E  E  TRUE
## 17   A   A  A  TRUE
## 18   B   B  B  TRUE
## 19   B   B  B  TRUE
## 20   B   B  B  TRUE
</code></pre>

<p><br> </br></p>

<pre><code class="r">prdTstPml3AllEq &lt;- ( prdTstPml3[ , &#39;knn&#39; ] == prdTstPml3[ , &#39;svm&#39; ] &amp;&amp; prdTstPml3[ , &#39;svm&#39; ] == prdTstPml3[ , &#39;rf&#39; ] )
prdTstPml3AllEq # overall agreement
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p><br> </br></p>

<h2>Summary of Prediction Results</h2>

<p>All 3 algorithms produced the same consistent prediction on the 20-case testing dataset.  The prediction results of <em>Random Forest</em> classification with the highest accuracy of 99% are used to summarize the predicted activities of the 20 test cases.</p>

<pre><code class="r"># prediction matrix of each testing problem_id on training classe
prdTstPmlRfMtrx &lt;- with( testPmlF , table( classe = prdTstRf , probID = problem_id ) )
prdTstPmlRfMtrx
</code></pre>

<pre><code>##       probID
## classe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
##      A 0 1 0 1 1 0 0 0 1  1  0  0  0  1  0  0  1  0  0  0
##      B 1 0 1 0 0 0 0 1 0  0  1  0  1  0  0  0  0  1  1  1
##      C 0 0 0 0 0 0 0 0 0  0  0  1  0  0  0  0  0  0  0  0
##      D 0 0 0 0 0 0 1 0 0  0  0  0  0  0  0  0  0  0  0  0
##      E 0 0 0 0 0 1 0 0 0  0  0  0  0  0  1  1  0  0  0  0
</code></pre>

<p><br> </br></p>

<pre><code class="r"># Testing Prediction Files:
pml_write_files = function( x , pth = &#39;.&#39; ) {   # def path is cwd
    n = length( x )
    for( i in 1:n ) {
        filename = paste0( &#39;problem_id_&#39; , i , &#39;.txt&#39; )
        write.table( x[ i ] , file = file.path( pth , filename ) , quote = FALSE , row.names = FALSE , col.names = FALSE )
    }
}

pml_write_files( prdTstPml3$rf )
</code></pre>

<p><br> </br></p>

<h3>gitHub commit files:</h3>

<p>GitHub repository <em>PracticalML_Project1</em> contains the following files:</p>

<ul>
<li>proj1_pml_practML.Rmd</li>
<li>README.md</li>
<li>ldPmlPrjDat.R</li>
<li>provlem<em>id</em>*.txt
<br> </br></li>
</ul>

</body>

</html>
